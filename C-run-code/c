#!/usr/bin/env bash
# https://github.com/Mehdidjah/c
# Enhanced C/C++/Fortran script compiler and executor

readonly VERSION="0.16.0"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

VERBOSE=false
DRY_RUN=false
SHOW_TIME=false

# max cachesize in kilobytes (default=5MB)
[[ -z "$C_CACHE_SIZE" ]] && C_CACHE_SIZE=$((5*1024))
if ! [[ "$C_CACHE_SIZE" =~ ^[0-9]+$ ]]; then
    C_CACHE_SIZE=$((5*1024))
    warn "C_CACHE_SIZE should be a positive integer, using default"
fi

log() {
    [[ "$VERBOSE" == true ]] && echo -e "${CYAN}[INFO]${NC} $*" >&2
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

success() {
    echo -e "${GREEN}[OK]${NC} $*" >&2
}

to_lower() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

get_ext() {
    local file="$1"
    local basename="${file##*/}"
    local ext="${basename##*.}"
    if [[ "$ext" == "$basename" ]]; then
        echo ""
    else
        to_lower "$ext"
    fi
}

format_size() {
    local bytes=$1
    if [[ $bytes -lt 1024 ]]; then
        echo "${bytes}B"
    elif [[ $bytes -lt $((1024*1024)) ]]; then
        echo "$((bytes/1024))KB"
    else
        echo "$((bytes/(1024*1024)))MB"
    fi
}

show_cache_info() {
    if [[ ! -d "$tmproot" ]] || [[ -z "$(ls -A "$tmproot" 2>/dev/null)" ]]; then
        echo "Cache is empty"
        return 0
    fi

    local ducmd
    if [[ "$(uname -s)" == "SunOS" ]]; then
        ducmd="du -ks"
    else
        ducmd="du -kc"
    fi

    local cache_size
    cache_size="$($ducmd "$tmproot" 2>/dev/null | tail -1 | awk '{print $1}')"
    local file_count
    file_count=$(find "$tmproot" -type f -name "*.bin" 2>/dev/null | wc -l | tr -d ' ')

    echo "Cache location: $tmproot"
    echo "Cache size: $(format_size $((cache_size*1024))) / $(format_size $((C_CACHE_SIZE*1024)))"
    echo "Cached binaries: $file_count"
    echo "Max cache size: $(format_size $((C_CACHE_SIZE*1024)))"
}

list_cache() {
    if [[ ! -d "$tmproot" ]] || [[ -z "$(ls -A "$tmproot" 2>/dev/null)" ]]; then
        echo "No cached binaries found"
        return 0
    fi

    echo "Cached binaries:"
    echo "================"
    local count=0
    while IFS= read -r bin; do
        if [[ -f "$bin" ]] && [[ -x "$bin" ]]; then
            local size
            size=$(stat -f%z "$bin" 2>/dev/null || stat -c%s "$bin" 2>/dev/null || echo "0")
            local mtime
            mtime=$(stat -f%Sm "$bin" 2>/dev/null || stat -c%y "$bin" 2>/dev/null | cut -d' ' -f1-2 || echo "unknown")
            ((count++))
            echo "[$count] $(basename "$bin") - $(format_size "$size") - $mtime"
        fi
    done < <(find "$tmproot" -type f -name "*.bin" 2>/dev/null | sort)
    echo "Total: $count binaries"
}

show_compiler_info() {
    echo "Compiler Information:"
    echo "====================="
    echo "CC: $CC"
    if command -v "$CC" &>/dev/null; then
        echo "Version:"
        "$CC" --version 2>&1 | head -1
    else
        error "Compiler $CC not found"
    fi
    
    if [[ -n "$CXX" ]] && command -v "$CXX" &>/dev/null; then
        echo ""
        echo "CXX: $CXX"
        echo "Version:"
        "$CXX" --version 2>&1 | head -1
    fi
    
    if [[ -n "$FC" ]] && command -v "$FC" &>/dev/null; then
        echo ""
        echo "FC: $FC"
        echo "Version:"
        "$FC" --version 2>&1 | head -1
    fi
}

cleanup() {
    [[ -n "$tmpdir" ]] && rm -rf "$tmpdir"

    if [[ ! -d "$tmproot" ]] || [[ -z "$(ls -A "$tmproot" 2>/dev/null)" ]]; then
        return 0
    fi

    local ducmd
    if [[ "$(uname -s)" == "SunOS" ]]; then
        ducmd="du -ks"
    else
        ducmd="du -kc"
    fi

    local cache_size
    cache_size="$($ducmd "$tmproot" 2>/dev/null | tail -1 | awk '{print $1}')"
    
    while [[ -n "$cache_size" ]] && [[ "$cache_size" -gt "$C_CACHE_SIZE" ]]; do
        [[ -z "$(ls -A "$tmproot" 2>/dev/null)" ]] && break
        
        local oldest
        oldest="$(find "$tmproot" -mindepth 1 -maxdepth 1 -type f -o -type d | sort | head -1)"
        [[ -n "$oldest" ]] && rm -rf "$oldest"
        
        cache_size="$($ducmd "$tmproot" 2>/dev/null | tail -1 | awk '{print $1}')"
        [[ -z "$cache_size" ]] && break
    done
}

help_msg() {
    >&$1 cat <<EOM
Usage: $(basename "$0") [OPTIONS] <FILE.C> [COMPILER_FLAGS] [ARGUMENTS]

Compile and execute C/C++/Fortran "scripts" in one go!
___

EXAMPLES
  $ c main.c
  $ c main.c arg1 arg2
  $ c 'main.c other.c' arg1 arg2
  $ c 'main.c -lncurses' arg1 arg2
  $ c -v main.c                    # Verbose mode
  $ c --time main.c                # Show compilation time
___

OPTIONS
  --help, -h          Show this help message
  --version           Show version information
  --clear-cache       Clear compilation cache
  --cache-info        Show cache information
  --list-cache        List all cached binaries
  --compiler-info     Show compiler information
  --verbose, -v       Verbose output
  --time              Show compilation and execution time
  --dry-run           Show what would be executed without running
EOM
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            help_msg 1
            exit 0
            ;;
        --version)
            echo "$VERSION"
            exit 0
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --time)
            SHOW_TIME=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            VERBOSE=true
            shift
            ;;
        --cache-info)
            [[ -z "$tmproot" ]] && {
                [[ -z "$TMPDIR" ]] && TMPDIR="/tmp"
                tmproot="$TMPDIR/c.cache.$USER"
            }
            show_cache_info
            exit 0
            ;;
        --list-cache)
            [[ -z "$tmproot" ]] && {
                [[ -z "$TMPDIR" ]] && TMPDIR="/tmp"
                tmproot="$TMPDIR/c.cache.$USER"
            }
            list_cache
            exit 0
            ;;
        --compiler-info)
            [[ -z "$CC" ]] && CC=cc
            [[ -z "$CXX" ]] && CXX=c++
            [[ -z "$FC" ]] && FC=gfortran
            show_compiler_info
            exit 0
            ;;
        --clear-cache)
            [[ -z "$tmproot" ]] && {
                [[ -z "$TMPDIR" ]] && TMPDIR="/tmp"
                tmproot="$TMPDIR/c.cache.$USER"
            }
            if [[ -d "$tmproot" ]]; then
                rm -rf "$tmproot"
                success "Cache cleared"
            else
                echo "Cache is already empty"
            fi
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            error "Unknown option: $1"
            help_msg 2
            exit 2
            ;;
        *)
            break
            ;;
    esac
done

[[ "$#" -lt 1 ]] && { help_msg 2; exit 2; }

if [[ -z "$tmproot" ]]; then
    if [[ -n "$C_CACHE_PATH" ]]; then
        tmproot="$C_CACHE_PATH"
    else
        [[ -z "$TMPDIR" ]] && TMPDIR="/tmp"
        tmproot="$TMPDIR/c.cache.$USER"
    fi
fi

[[ -z "$CC" ]]  && CC=cc
[[ -z "$FC" ]]  && FC=gfortran
[[ -z "$CXX" ]] && CXX=c++

if ! command -v "$CC" &>/dev/null; then
    error "\$CC ($CC) not found"
    exit 1
fi

log "Using compiler: $CC"

comp=()
fname=""
prog_args_start=0

if [[ -f "$1" ]]; then
    comp=("$1")
    fname="$1"
    prog_args_start=2
    log "Single file mode: $fname"
else
    if [[ "$#" -eq 1 ]] || [[ "$1" =~ [[:space:]] ]]; then
        for arg in $1; do
            if [[ "$arg" == "--" ]]; then
                if [[ $# -ge 2 ]]; then
                    fname="$2"
                    comp=("$2" "${comp[@]}")
                    prog_args_start=3
                fi
                break
            else
                comp+=("$arg")
            fi
        done
        [[ "$prog_args_start" -eq 0 ]] && [[ $# -gt 1 ]] && prog_args_start=2
    else
        for ((i=1; i<=$#; i++)); do
            arg="${!i}"
            if [[ "$arg" == "--" ]]; then
                if [[ $((i+1)) -le $# ]]; then
                    fname="${!((i+1))}"
                    comp=("$fname" "${comp[@]}")
                    prog_args_start=$((i+2))
                fi
                break
            else
                comp+=("$arg")
            fi
        done
        [[ "$prog_args_start" -eq 0 ]] && prog_args_start=$((${#comp[@]} + 2))
    fi

    if [[ -z "$fname" ]]; then
        for arg in "${comp[@]}"; do
            if [[ "$arg" != -* ]] && [[ -f "$arg" ]]; then
                fname="$arg"
                break
            fi
        done
        if [[ -z "$fname" ]] && [[ "$#" -eq 1 ]]; then
            for arg in $1; do
                if [[ "$arg" != -* ]] && [[ -f "$arg" ]]; then
                    fname="$arg"
                    break
                fi
            done
        fi
        if [[ -n "$fname" ]] && [[ "$prog_args_start" -eq 0 ]]; then
            for ((i=1; i<=$#; i++)); do
                [[ "${!i}" == "$fname" ]] && { prog_args_start=$((i+1)); break; }
            done
        fi
    fi
    log "Multi-file mode: ${comp[*]}"
fi

mkdir -p "$tmproot" || { error "Failed to create cache directory"; exit 1; }
chmod 700 "$tmproot" 2>/dev/null || true
log "Cache directory: $tmproot"

potential_hashes=(md5sum sha256sum sha1sum shasum)
hash_func=""
for hf in "${potential_hashes[@]}"; do
    if command -v "$hf" &>/dev/null; then
        hash_func="$hf"
        break
    fi
done

if [[ -z "$hash_func" ]]; then
    C_CACHE_SIZE=0
    warn "No hash function found, caching disabled"
else
    log "Using hash function: $hash_func"
fi

is_cpp=false
is_fortran=false
for f in "$fname" "${comp[@]}"; do
    [[ -f "$f" ]] || continue

    ext=$(get_ext "$f")

    if [[ "$ext" =~ ^(cc|c\+\+|cpp|cxx)$ ]]; then
        is_cpp=true
        if command -v "$CXX" &>/dev/null; then
            CC="$CXX"
            [[ -n "$CXXFLAGS" ]] && comp+=("$CXXFLAGS")
        else
            [[ -n "$CFLAGS" ]] && comp+=("$CFLAGS")
            comp+=("-lstdc++")
        fi
        log "Detected C++ code"
        break
    fi

    if [[ "$ext" =~ ^(f|f95|f77|f90|f03|f15|for)$ ]]; then
        is_fortran=true
        CC="$FC"
        [[ -n "$FCFLAGS" ]] && comp+=("$FCFLAGS")
        log "Detected Fortran code"
        break
    fi
done

[[ "$is_cpp" == false && "$is_fortran" == false ]] && [[ -n "$CFLAGS" ]] && comp+=("$CFLAGS")
[[ -n "$CPPFLAGS" ]] && comp+=("$CPPFLAGS")

prehash="$CC ${comp[*]}"
for f in "${comp[@]}"; do
    if [[ -f "$f" ]]; then
        if command -v cpp &>/dev/null; then
            prehash+="$f $(cpp "$f" 2>&1)"
        else
            prehash+="$f $(cat "$f" 2>/dev/null)"
        fi
    fi
done

if [[ -n "$hash_func" ]]; then
    id="c$("$hash_func" <<< "$prehash" | awk '{print $1}')"
else
    id="c$(echo "$prehash" | od -A x -t x1 2>/dev/null | head -1 | tr -d ' \n' || echo "$(date +%s)")"
fi
tmpdir="$tmproot/$id.src"
binname="$tmproot/$id.bin"

log "Cache key: $id"

run() {
    trap cleanup SIGINT SIGTERM

    if [[ -x "$binname" ]]; then
        if [[ "$prog_args_start" -gt 0 ]] && [[ "$prog_args_start" -le $# ]]; then
            prog_args=("${@:$prog_args_start}")
        else
            prog_args=("$@")
        fi
        
        if [[ "$DRY_RUN" == true ]]; then
            echo "Would execute: $binname ${prog_args[*]}"
            exit 0
        fi
        
        start_time=""
        [[ "$SHOW_TIME" == true ]] && start_time=$(date +%s.%N)
        
        (exec -a "$fname" "$binname" "${prog_args[@]}")
        ret=$?
        
        if [[ "$SHOW_TIME" == true ]] && [[ -n "$start_time" ]]; then
            end_time=$(date +%s.%N)
            elapsed=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "0")
            echo -e "${BLUE}Execution time: ${elapsed}s${NC}" >&2
        fi
    else
        error "Binary not found or not executable"
        ret=4
    fi

    trap - SIGINT SIGTERM
    cleanup
    exit $ret
}

if [[ -f "$binname" ]] && [[ -x "$binname" ]]; then
    log "Using cached binary"
    [[ "$SHOW_TIME" == true ]] && echo -e "${GREEN}Cache hit!${NC}" >&2
    run "$@"
else
    log "Cache miss, compiling..."
    mkdir -p "$tmpdir" || { error "Failed to create temporary directory"; exit 1; }
fi

includes=()
includes+=("-I$(pwd)")

for f in "${comp[@]}"; do
    if [[ -f "$f" ]]; then
        dir="$(dirname "$f")"
        duplicate=false
        for inc in "${includes[@]}"; do
            [[ "$inc" == "-I$dir" ]] && { duplicate=true; break; }
        done
        [[ "$duplicate" == false ]] && includes+=("-I$dir")
    fi
done

log "Include directories: ${includes[*]}"

i=0
for f in "${comp[@]}"; do
    if [[ -f "$f" ]] && [[ "$f" != "$tmpdir"* ]]; then
        dest_dir="$tmpdir/$(dirname "$f")"
        mkdir -p "$dest_dir" || { error "Failed to create directory $dest_dir"; exit 1; }
        cp "$f" "$tmpdir/$f" || { error "Failed to copy $f"; exit 1; }
        log "Copied: $f -> $tmpdir/$f"

        base="$(basename "$f")"
        ext="${base##*.}"
        if [[ "$ext" == "$base" ]]; then
            comp[$i]="-x c $tmpdir/$f -x none"
        else
            comp[$i]="$tmpdir/$f"
        fi

        if head -n1 "$tmpdir/$f" 2>/dev/null | grep -q '^#!'; then
            sed '1d' "$tmpdir/$f" > "$tmpdir/$f.tmp" && mv "$tmpdir/$f.tmp" "$tmpdir/$f"
            log "Removed shebang from $f"
        fi
    fi
    ((i++))
done

rest=()
flags=()
for f in "${comp[@]}"; do
    [[ -z "$f" ]] && continue
    if [[ "$f" =~ ^- ]]; then
        flags+=("$f")
    else
        rest+=("$f")
    fi
done

optimization_level="${C_OPT_LEVEL:-O2}"
compile_cmd=("$CC" "-$optimization_level" -o "$binname")
compile_cmd+=("${flags[@]}")
compile_cmd+=("${includes[@]}")
compile_cmd+=("${rest[@]}")

log "Compile command: ${compile_cmd[*]}"

if [[ "$DRY_RUN" == true ]]; then
    echo "Would compile with: ${compile_cmd[*]}"
    exit 0
fi

start_time=""
[[ "$SHOW_TIME" == true ]] && start_time=$(date +%s.%N)

compile_output="$("${compile_cmd[@]}" 2>&1)"
compile_status=$?

if [[ "$SHOW_TIME" == true ]] && [[ -n "$start_time" ]]; then
    end_time=$(date +%s.%N)
    elapsed=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "0")
    echo -e "${BLUE}Compilation time: ${elapsed}s${NC}" >&2
fi

if [[ $compile_status -eq 0 ]]; then
    success "Compilation successful"
    run "$@"
else
    error "Compilation failed"
    echo -n "$compile_output" >&2
    cleanup
    exit 1
fi
